FORMAT: 1A
HOST: https://token-identity-service.herokuapp.com/

# Identity Service

this is service which stores user identities, and information associated with those accounts

## Short term goals

To provide a basic username -> public key mapping to give users an
identity that is verifyable by other users.

## Long term goals

To be decentralised, using the ethereum blockchain to publically store
the username -> key mappings, removing the need for people to trust
the token service that the data it's providing is accurate.

### Existing work in the wild

* [Blockchain-ID](https://github.com/blockstack/blockchain-id/wiki) : Specification for
  identity stored on the blockchain. Proposed by [Blockstack](https://blockstack.org).
  Designed to be blockchain agnostic, but reference implementation is built ontop of
  bitcoin. Involves an additional platform ontop of bitcoin that filters out bitcoin
  transactions that have blockstack sepecific operations (name registration, transfers,
  etc) and from that builds a DHT containing the data for each of the identities.
  ([github](https://github.com/blockstack))
* [Onename](https://onename.com) : Service for providing Blockchain-ID's.
  ([github](https://github.com/onenameio))
  ([api docs](https://api.onename.com/))
* [Uport](https://uport.me) : Ethereum specific blockchain identity. Similar to
  Blockchain-ID, but makes use of special ethereum contracts for identity registration
  and lookup. Identity recovery is unique here as they use a network of trust for recovery.
  That is, a user can delegate a number of trusted people such that if a user loses the
  device with the keys to the ethereum address currently linked to their identity, they can
  simply generate new keys and get the trusted people to verify that the new address is the
  owner of the identity, which will trigger a transfer of identity.
  Uses [IPFS](https://ipfs.io/) for storage of an identity's details.
  ([github](https://github.com/ConsenSys))
* [Tradle](http://tradle.io/app/Tradle/home/) : Similar to BlockStack (as far as i
  have looked into them, which isn't that much so far)
  ([wiki](https://github.com/tradle/about/wiki))
* [Deloitte Smart ID](http://www.deloitte.co.uk/smartid/) : not much technical
  information on this yet.
* [Thomson Reuters BlockOneId](https://blockone.thomsonreuters.com/) *a user
  entitlement framework that allows blockchain developers to control which
  users can access their smart contracts.*

Some common observations around these:
* [JWT](https://jwt.io/) used for authentication
* All use the profile schema defined by Blockstack ([see here](https://github.com/blockstack/blockchain-id/wiki/Profile-Schema-v3))
* As blockchain storage is expensive, all use some kind of DHT to store more detailed
  information, only storing pointers to the DHT data on the blockchain.
* There is a lot to consider in designing a trust worthy decentralised indentity
  platform.

# Conventions

* Signing done using Ethereum style signatures
* Keys and signatures transfered in URL-Safe Base64 with any trailing equal
  signs `=` removed
* `username` restricted to `^[a-z0-9_]{1,60}$`,

# Authentication/Verification

Endpoints that require user verification are required to have a signature attached.
The basic structure for these requests is

    {
        "payload": { ... },
        "signature": "..."
    }

The signature is generated by signing a message containing the full json encoding of the
payload with all the whitespace removed.

`ts` (timestamp) is always included in authenticated requests to prevent replay attacks.

## Name Registration [/register]

Used to register a new username -> public key mapping.

**Possible Errors**:
 * `username_taken`
 * `invalid_signature`
 * `bad_arguments`

### Name Registration [POST]

**TODO**:

 * think about non-on-boarded clients (maybe they can just pick a random username,
   which the user can change when going through real onboarding)
 * does it make sense to even have non-on-boarded clients anymore? or at least
   does it make sense to not have a "basic" onboarding which is picking a username
   and passphrase for the private key.
 * should `username` be the user's unique identified. 
 * if so should they be allowed to change it in the future?

+ Request (application/json)

        {
            "payload": {
                "username": "tristan",
                "publickey": "tY0WwhmYeulxq4yhByCBvwd7LaRsprY-GzfKA11LfyLZIaTlvqEX8ncKjSdbdoZWatHt2kh9IvCOTDmZOJEmvw",
                "ts": 1479827948.535719
            },
            "signature": "wQD7XsApXoJ0VJqDVknfCoXqDFhNPex0VNSJLokG24VN2YyPIuIN5O8oKbnhs1aI0jD_aA5AQGCH6Clqupo87AE"
        }

+ Response 200 (application/json)

        {
            "user": {
                "username": "tristan",
                "owner_address": "0x676f7cb80c9ff6a55e8992d94bac9a3212282c3a",
                "publickey": "tY0WwhmYeulxq4yhByCBvwd7LaRsprY-GzfKA11LfyLZIaTlvqEX8ncKjSdbdoZWatHt2kh9IvCOTDmZOJEmvw"
            }
        }

+ Response 400 (application/json)

        {
            "error": "..."
        }


## User Lookup/Update [/user/{username}]

Used to view public information about a user

+ Parameters

    + username: tristan - The requested user's username

### Name Lookup [GET]

Used to request the public details of a user, including their public key that
can be used to verify signatures.

+ Response 200 (application/json)

        {
            "tristan": {
                "owner_address": "0x676f7cb80c9ff6a55e8992d94bac9a3212282c3a",
                "publickey": "tY0WwhmYeulxq4yhByCBvwd7LaRsprY-GzfKA11LfyLZIaTlvqEX8ncKjSdbdoZWatHt2kh9IvCOTDmZOJEmvw"
            }
        }

+ Response 404

### Profile Update [POST]

Allows the user to change details of their profile.

**TODO**: there's currently no details other than username and public key.
so this doesn't make much sense unless we allow updating of those things.

+ Request (application/json)

        {
            "payload": {
            },
            "signature": ""
        }

+ Response 200

## Private Key Backup [/backup]

**TODO**: How much sense does this makes sense in the decentralised world?
Previously we used a password to restrict access to the stored private key
backup, even though it was encrypted. But in the decentralised world there is
no central body to store/verify the passwords.

It would be simple enough to store the encrypted key somewhere public in much
the same way other details are stored in a decentralised way (via ipfs or
something similar), but it would mean that the users private key is free for
anyone to attempt to crack, which is not desireable.

I think it would be better to simply generate the key client side with a
mnemonic seed and have the user understand they need to keep that mnemonic 
safe somewhere for recovery of a lost key (this could be kept in a password
manager or something even if the user isn't super worried about security).

### Backup encrypted private key [POST]

+ Response 200
